import 'mocha';
import { expect } from 'chai';
import { ethers } from 'hardhat';
import { Wallet } from 'ethers';
import { RandomNumber } from '../src/classes/RandomNumber';
import { KeyPair } from '../src/classes/KeyPair';
import { StealthPay } from '../src/classes/StealthPay';
import * as utils from '../src/utils/utils';
import { expectRejection } from './utils';
import { testPrivateKeys } from './testPrivateKeys';

const ethersProvider = ethers.provider;

// Number of runs for tests that execute in a loop. Some tests will fail if this is above 100, because
// they rely on the fact that 100 accounts are generated by default in the hardhat config
const numberOfRuns = 100;

// Define public key that is not on the curve. This point was generated from a valid public key ending in
// `83b3` and we took this off the curve by changing the final digits to `83b4`
const badPublicKey = '0x04059f2fa86c55b95a8db142a6a5490c43e242d03ed8c0bd58437a98709dc9e18b3bddafce903ea49a44b78d57626448c83f8649d3ec4e7c72d8777823f49583b4'; // prettier-ignore

// Address, public key (not used), and private key from first deterministic ganache account
const address = '0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1';
const publicKey =
  '0x04e68acfc0253a10620dff706b0a1b1f1f5833ea3beb3bde2250d5f271f3563606672ebc45e0b7ea2e816ecb70ca03137b1c9476eec63d4632e990020b7b6fba39';
const privateKey = '0x4f3edf983ac636a65a842ce7c78d9aa706d3b113bce9c46f30d7d21715b23b1d';

describe('KeyPair class', () => {
  let wallet: Wallet;
  // 将会在每个测试用例执行前执行，可以用于准备测试用例所需的前置条件
  //beforeEach(() => {
  beforeEach(() => {
    wallet = Wallet.createRandom();
  });

  describe('Initialization', () => {
    //通过私钥得到keyPair->地址
    it('initializes an instance with valid private key', () => {
      // Check against ganache account
      const keyPair = new KeyPair(privateKey);
      expect(keyPair.address).to.equal(address);

      // Check against random wallet
      const keyPair2 = new KeyPair(wallet.privateKey);

      expect(keyPair2.address).to.equal(wallet.address);

      const publicKey =
        '0x047ed97b2573a44010b4f7280822e04bc74cf1360ace605682ae6ca5f2d6d6fa3d39ef6daffc32c78bd20a187848acbe5bb542dedd65a07ce1167e9d3c394f2124';
      console.log('已知公钥:', publicKey);

      //公钥得到地址
      const keyPair3 = new KeyPair(publicKey);
      console.log('从公钥获得地址:', keyPair3.address);
      console.log('从公钥获得私钥:', keyPair3.privateKeyHex);

      //私钥得到公钥
      const keyPair4 = new KeyPair(privateKey);
      console.log('私钥得到公钥:', keyPair4.publicKeyHex);
      console.log('私钥得到地址:', keyPair4.address);
    });

    //通过公钥得到keyPair->地址
    it('initializes an instance with valid public key', () => {
      const keyPair = new KeyPair(wallet.publicKey);

      //console.log("keyPair.address:"+keyPair.address);
      expect(keyPair.address).to.equal(wallet.address);
    });

    //通过txHash获取keyPair->From地址
    it('initializes an instance from a regular transaction', async () => {
      // Specify rinkeby transaction hash and its sender
      const txHash = '0x16fd6521083f4af7cefad0e11261c6e23a20b3b256cab992389f8b6d120d56f0';
      const from = '0xbC61B73d3b8eea27Ce69AaE05C2457a5ADA04438';
      // Create instance and check result
      const keyPair = await KeyPair.instanceFromTransaction(txHash, ethersProvider);
      console.log('keyPair.publicKeyHex:' + keyPair.publicKeyHex);
      expect(keyPair.address).to.equal(from);
    });

    //通过txHash获取keyPair->From地址
    it('initializes an instance from a contract interaction transaction', async () => {
      // Specify rinkeby transaction hash and its sender
      const txHash = '0x7f5c8ad1ccfe2582b1ec98635cca68648ffa898b893ee5c694ef8146596c812d';
      const from = '0xbC61B73d3b8eea27Ce69AaE05C2457a5ADA04438';
      // Create instance and check result
      const keyPair = await KeyPair.instanceFromTransaction(txHash, ethersProvider);
      //console.log("contract transaction address:" + keyPair.address);
      expect(keyPair.address).to.equal(from);
    });

    //通过txHash获取keyPair->From地址
    it('initializes an instance from a contract creation transaction', async () => {
      // Specify rinkeby transaction hash and its sender
      const txHash = '0x7f5c8ad1ccfe2582b1ec98635cca68648ffa898b893ee5c694ef8146596c812d';
      const from = '0xbC61B73d3b8eea27Ce69AaE05C2457a5ADA04438';
      // Create instance and check result
      const keyPair = await KeyPair.instanceFromTransaction(txHash, ethersProvider);
      // console.log("contract create address:" + keyPair.address);
      expect(keyPair.address).to.equal(from);
    });
  });

  describe('Functionality', () => {
    //将从一个任意的交易中恢复公钥
    it('will recover the public key from an arbitrary transaction', async () => {
      // Specify rinkeby transaction hash and its sender
      const txHash = '0xb72708c3c414d6757c924f812913a351d0f9a89ce11d3fc22381980f0253e04f';
      const sendersPublicKey =
        '0x04972a34d8f2ded8515b1b32234fe305273a8a680643bea54e33cb0b862130f6af3088686afefb99b3b6bf9bb3af4ac8f193f7326be203984dceda2791eff47c53';
      // Create instance and check result
      const recoveredPublicKey = await utils.recoverPublicKeyFromTransaction(txHash, ethersProvider);
      expect(recoveredPublicKey).to.equal(sendersPublicKey);
    });

    it('create privateKeys'),
      async () => {
        // Sender computes receiving address from random number and recipient's public key
        const randomNumber = new RandomNumber();
        const recipientFromPublic = new KeyPair(wallet.publicKey);
        const stealthFromPublic = recipientFromPublic.mulPublicKey(randomNumber); //公钥乘以randomNumber

        // Recipient computes new private key from random number and derives receiving address
        const recipientFromPrivate = new KeyPair(wallet.privateKey);
        const stealthFromPrivate = recipientFromPrivate.mulPrivateKey(randomNumber); //私钥乘以randomNumber
      };

    //压缩和解压缩公钥
    it('properly compresses and uncompresses public keys', async () => {
      // Known set of private keys that fail if compressed public key is not padded to 32 bytes (in
      // other words, these private keys generate public keys that start with a zero-byte)
      // prettier-ignore

      //已知的一组私钥，如果压缩后的公钥没有被填充到32字节，就会失效（换句话说，这些私钥生成的公钥以零字节开始）
      const privateKeys = [
        '0x7a79b9a28a51ff8704238959a7b19dd43149698b32065559948419e650636f68',
        '0xa1275d22f814d1e766d76eeea4f97584a322bec236176d291c3a46856b8d8770',
        '0xa5e4845e9d1bd6e546ee6655519a4400a9b591afc1fc09c74016a6e17c27c47b',
        '0x2a618897e58ef3a09a1c3f8b32931bc08fc671e00545b9e919fb418367eec49d',
        '0xa01d066e7f01d664296fbab225d86590555e762f021f73a6837ab69a4b20fb32',
        '0xdbe0800f84f57e58f16b346fe8b6c264700a5adbb70bb522bd3ee4b75f3d59c7',
        '0xed8dee728fb529b9fa1a78e205685e632609c0b43600048323fde68353990be7',
      ];
      for (let i = 0; i < privateKeys.length; i += 1) {
        wallet = new Wallet(privateKeys[i]);

        //console.log("wallet address:" + wallet.publicKey);

        //压缩公钥
        const compressedPublicKey = KeyPair.compressPublicKey(wallet.publicKey);

        //解压公钥
        const uncompressedPublicKey = KeyPair.getUncompressedFromX(
          compressedPublicKey.pubKeyXCoordinate,
          compressedPublicKey.prefix
        );

        // console.log("wallet address:" + uncompressedPublicKey);
        expect(uncompressedPublicKey).to.equal(wallet.publicKey);
      }

      // Repeat again but with random private keys
      for (let i = 0; i < numberOfRuns; i += 1) {
        wallet = Wallet.createRandom();
        const compressedPublicKey = KeyPair.compressPublicKey(wallet.publicKey);
        const uncompressedPublicKey = KeyPair.getUncompressedFromX(
          compressedPublicKey.pubKeyXCoordinate,
          compressedPublicKey.prefix
        );
        expect(uncompressedPublicKey).to.equal(wallet.publicKey);
      }
    });

    it('successfully decrypts random number regardless of ephemeral public key prefix', async () => {
      //for (let i = 0; i < numberOfRuns; i += 1) {
      // Recipient account setup. We must use a default hardhat account so hardhat has access to the private
      // key to sign with `provider.send('personal_sign', [params])`, but we instantiate the wallet manually
      // with the private key since the SignerWithAddress type is not a valid input type to generatePrivateKeys
      //收件人账户设置。我们必须使用一个默认的hardhat账户，这样hardhat就可以获得私钥，用`provider.send('personal_sign', [params])`进行签名，
      //但是我们用私钥手动实例化钱包，因为SignerWithAddress类型不是生成私钥的有效输入类型。

      // const recipientHardhat = (await ethers.getSigners())[i];
      const recipientHardhat = new Wallet(testPrivateKeys[0]);
      console.log('recipientHardhat.address:' + recipientHardhat.address);

      const recipient = new Wallet(testPrivateKeys[0]);
      console.log('recipient.address:' + recipient.address);

      //if (recipientHardhat.address !== recipient.address) throw new Error('Address mismatch');

      const stealthpay = new StealthPay(ethersProvider, 5); //5表示网络

      const { viewingKeyPair } = await stealthpay.generatePrivateKeys(recipient);

      // Simulate sender encrypting the random number
      const randomNumber = new RandomNumber();
      const encrypted = viewingKeyPair.encrypt(randomNumber);

      // Pull out the data that is published to chain and emitted as an event
      const { ciphertext } = encrypted;
      const { pubKeyXCoordinate } = KeyPair.compressPublicKey(encrypted.ephemeralPublicKey);

      // Assume 02 prefix and decrypt
      const uncompressedPubKey1 = KeyPair.getUncompressedFromX(pubKeyXCoordinate, 2);
      const payload1 = { ephemeralPublicKey: uncompressedPubKey1, ciphertext };
      const randomNumber1 = viewingKeyPair.decrypt(payload1);
      expect(randomNumber1).to.equal(randomNumber.asHex);

      // Assume 03 prefix and decrypt
      const uncompressedPubKey2 = KeyPair.getUncompressedFromX(pubKeyXCoordinate, 3);
      const payload2 = { ephemeralPublicKey: uncompressedPubKey2, ciphertext };
      const randomNumber2 = viewingKeyPair.decrypt(payload2);
      expect(randomNumber2).to.equal(randomNumber.asHex);
      expect(uncompressedPubKey1).to.not.equal(uncompressedPubKey2); // confirm we took different paths to same result
      // }
    });

    //用基于密钥的构造方法正确地导出公钥参数
    it('properly derives public key parameters with both key-based constructor methods', () => {
      const keyPair1 = new KeyPair(wallet.privateKey);
      const keyPair2 = new KeyPair(wallet.publicKey);

      //console.log("keyPair1.publicKeyHex:"+keyPair1.publicKeyHex);
      //console.log("keyPair2.publicKeyHex:"+keyPair2.publicKeyHex);

      expect(keyPair1.publicKeyHex).to.equal(keyPair2.publicKeyHex);
      // expect(JSON.stringify(keyPair1.publicKeyEC)).to.equal(JSON.stringify(keyPair2.publicKeyEC));
    });

    //支持对随机数进行加密和解密
    it('supports encryption and decryption of the random number', async () => {
      // Do a bunch of tests with random wallets and numbers
      for (let i = 0; i < numberOfRuns; i += 1) {
        // Every 100th run print status update
        if ((i + 1) % 100 === 0) console.log(`Executing run ${i + 1} of ${numberOfRuns}...`);

        // Generate random wallet and encrypt payload
        const randomNumber = new RandomNumber();
        const wallet = Wallet.createRandom();
        const keyPairFromPublic = new KeyPair(wallet.publicKey);
        const output = await keyPairFromPublic.encrypt(randomNumber); // eslint-disable-line no-await-in-loop

        // Decrypt payload
        const keyPairFromPrivate = new KeyPair(wallet.privateKey);
        const plaintext = await keyPairFromPrivate.decrypt(output); // eslint-disable-line no-await-in-loop
        expect(plaintext).to.equal(randomNumber.asHex);
      }
    });

    //让发件人生成隐蔽的接收地址，让收件人可以访问。
    it('lets sender generate stealth receiving address that recipient can access', () => {
      for (let i = 0; i < numberOfRuns; i += 1) {
        // Every 100th run print status update
        if ((i + 1) % 100 === 0) console.log(`Executing run ${i + 1} of ${numberOfRuns}...`);

        // Sender computes receiving address from random number and recipient's public key
        const randomNumber = new RandomNumber();
        const recipientFromPublic = new KeyPair(wallet.publicKey);
        const stealthFromPublic = recipientFromPublic.mulPublicKey(randomNumber); //公钥乘以randomNumber

        // Recipient computes new private key from random number and derives receiving address
        const recipientFromPrivate = new KeyPair(wallet.privateKey);
        const stealthFromPrivate = recipientFromPrivate.mulPrivateKey(randomNumber); //私钥乘以randomNumber

        // Confirm outputs match
        expect(stealthFromPrivate.address).to.equal(stealthFromPublic.address); //地址是相同的
        expect(stealthFromPrivate.publicKeyHex).to.equal(stealthFromPublic.publicKeyHex); //publicKeyHex相同的
      }
    });

    //允许用随机数类或十六进制字符串进行乘法。
    it('lets multiplication be performed with RandomNumber class or hex string', () => {
      for (let i = 0; i < numberOfRuns; i += 1) {
        // Every 100th run, print status update and use the zero payload extension
        if ((i + 1) % 100 === 0) console.log(`Executing run ${i + 1} of ${numberOfRuns}...`);

        // Generate random number and wallet
        const randomNumber = new RandomNumber();
        const randomWallet = Wallet.createRandom();
        const randomFromPublic = new KeyPair(randomWallet.publicKey);
        const randomFromPrivate = new KeyPair(randomWallet.privateKey);

        // Compare public key multiplication
        const stealthFromClassPublic = randomFromPublic.mulPublicKey(randomNumber);
        const stealthFromStringPublic = randomFromPublic.mulPublicKey(randomNumber.asHex);
        expect(stealthFromClassPublic.address).to.equal(stealthFromStringPublic.address);

        // Compare private key multiplication
        const stealthFromClassPrivate = randomFromPrivate.mulPrivateKey(randomNumber);
        const stealthFromStringPrivate = randomFromPrivate.mulPrivateKey(randomNumber.asHex);
        expect(stealthFromClassPrivate.address).to.equal(stealthFromStringPrivate.address);

        const stealthFromClassPrivate2 = randomFromPrivate.mulPublicKey(randomNumber);
        const stealthFromStringPrivate2 = randomFromPrivate.mulPublicKey(randomNumber.asHex);
        expect(stealthFromClassPrivate2.address).to.equal(stealthFromStringPrivate2.address);
      }
    });

    //适用于任何随机生成的数字和钱包
    it('works for any randomly generated number and wallet', () => {
      let numFailures = 0;
      for (let i = 0; i < numberOfRuns; i += 1) {
        // Every 100th run, print status update and use the zero payload extension
        if ((i + 1) % 100 === 0) console.log(`Executing run ${i + 1} of ${numberOfRuns}...`);

        // Generate random number and wallet
        const randomNumber = new RandomNumber();
        const randomWallet = Wallet.createRandom();

        // Sender computes receiving address from random number and recipient's public key
        const recipientFromPublic = new KeyPair(randomWallet.publicKey);
        const stealthFromPublic = recipientFromPublic.mulPublicKey(randomNumber);

        // Recipient computes new private key from random number and derives receiving address
        const recipientFromPrivate = new KeyPair(randomWallet.privateKey);
        const stealthFromPrivate = recipientFromPrivate.mulPrivateKey(randomNumber);

        // Confirm outputs match
        if (
          stealthFromPrivate.address !== stealthFromPublic.address ||
          stealthFromPrivate.publicKeyHex !== stealthFromPublic.publicKeyHex
        ) {
          numFailures += 1;
          console.log();
          console.log(`FAILURE #${numFailures} ========================================`);
          console.log('Inputs');
          console.log('  Wallet Private Key:  ', wallet.privateKey);
          console.log('  Wallet Public Key:   ', wallet.publicKey);
          console.log('  Wallet Address:      ', wallet.address);
          console.log('  Random Number:       ', randomNumber.asHex);
          console.log('Outputs');
          console.log('  Stealth from Public,  Address:     ', stealthFromPublic.address);
          console.log('  Stealth from Private, Address:     ', stealthFromPrivate.address);
          console.log('  Stealth from Public,  Public Key:  ', stealthFromPublic.publicKeyHex);
          console.log('  Stealth from Private, Public Key:  ', stealthFromPrivate.publicKeyHex);
        }
      }
      expect(numFailures).to.equal(0);
    });
  });

  //Input validation
  describe('Input validation', () => {
    // ts-expect-error statements needed throughout this section to bypass TypeScript checks that would stop this file
    // from being compiled/ran

    //如果使用公钥创建钱包时privateKeyHex和privateKeyHexSlim 是null
    it('returns null for private key parameters when created with a public key', () => {
      const keyPair = new KeyPair(wallet.publicKey);
      expect(keyPair.privateKeyHex).to.equal(null);
      expect(keyPair.privateKeyHexSlim).to.equal(null);
    });

    //验证PrivateKey和PublicKey的格式
    it('throws when initializing with an invalid key', () => {
      const errorMsg1 = 'Key must be a string in hex format with 0x prefix'; //必须0x开头
      const errorMsg2 = 'Key must be a 66 character hex private key or a 132 character hex public key'; //必须是66个字符Hex或者132字符hex
      const errorMsg3 = 'Cannot initialize KeyPair with the provided key'; //不能使用完为0的私钥
      const zeroPrivateKey = '0x0000000000000000000000000000000000000000000000000000000000000000';
      const zeroPublicKey =
        '0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'; //不能使用完为0的公钥

      // @ts-expect-error
      expect(() => new KeyPair(1)).to.throw(errorMsg1);
      expect(() => new KeyPair(privateKey.slice(2))).to.throw(errorMsg1);
      expect(() => new KeyPair(wallet.publicKey.slice(4))).to.throw(errorMsg1);
      expect(() => new KeyPair('0x1234')).to.throw(errorMsg2);
      expect(() => new KeyPair(zeroPrivateKey)).to.throw(errorMsg3);
      expect(() => new KeyPair(zeroPublicKey)).to.throw(errorMsg3);
    });

    //当用不在曲线上的公钥初始化时，会抛出一个问题。解理：公钥必须是曲线算法生成的公钥
    it('throws when initializing with a public key not on the curve', () => {
      expect(() => new KeyPair(badPublicKey)).to.throw('Point is not on elliptic curve');
    });

    //加密时必须使用RandomNumber生成的随机数
    it('throws when trying to encrypt with a bad input', async () => {
      const keyPairFromPublic = new KeyPair(wallet.publicKey);
      const errorMsg = 'Must provide instance of RandomNumber';

      //必须使用RandomNumber生成的随机数
      // @ts-expect-error
      expect(() => keyPairFromPublic.encrypt('1')).to.throw(errorMsg);
      // @ts-expect-error
      expect(() => keyPairFromPublic.encrypt(1)).to.throw(errorMsg);
    });

    //解密时必须RandomNumber的随机数
    it('throws when trying to decrypt with a bad input', async () => {
      const keyPairFromPrivate = new KeyPair(wallet.privateKey);
      const errorMsg = 'Input must be of type EncryptedPayload to decrypt';
      // @ts-expect-error
      expect(() => keyPairFromPrivate.decrypt({ ephemeralPublicKey: '1' })).to.throw(errorMsg);
      // @ts-expect-error
      expect(() => keyPairFromPrivate.decrypt({ ciphertext: '1' })).to.throw(errorMsg);
      // @ts-expect-error
      expect(() => keyPairFromPrivate.decrypt('1')).to.throw(errorMsg);
      // @ts-expect-error
      expect(() => keyPairFromPrivate.decrypt(1)).to.throw(errorMsg);
    });

    //当试图用只有公钥的KeyPair解密时，会抛出一个问题。
    it('throws when trying to decrypt with a KeyPair that only has a public key', () => {
      const keyPairFromPublic = new KeyPair(wallet.publicKey);

      const dummyWallet = Wallet.createRandom();

      const dummyEncryptedData = {
        ephemeralPublicKey: dummyWallet.publicKey,
        ciphertext: dummyWallet.privateKey,
      };

      const errorMsg = 'KeyPair has no associated private key to decrypt with'; //密钥对没有相关的私钥可以解密

      expect(() => keyPairFromPublic.decrypt(dummyEncryptedData)).to.throw(errorMsg);
    });

    //当试图用不在曲线上的公钥解密时，会抛出一个问题。不太明白什么意思
    it('throws when trying to decrypt with a public key not on the curve', () => {
      const keyPairFromPrivate = new KeyPair(wallet.privateKey);
      const dummyWallet = Wallet.createRandom();
      const dummyEncryptedData = {
        ephemeralPublicKey: badPublicKey,
        ciphertext: dummyWallet.privateKey,
      };
      const dummyEncryptedData2 = {
        ephemeralPublicKey: badPublicKey.slice(2),
        ciphertext: dummyWallet.privateKey,
      };

      expect(() => keyPairFromPrivate.decrypt(dummyEncryptedData)).to.throw('Point is not on elliptic curve');
      expect(() => keyPairFromPrivate.decrypt(dummyEncryptedData2)).to.throw('Point is not on elliptic curve');
    });

    //验证乘以的数类似防坑
    it('throws when mulPublicKey is provided a bad input', async () => {
      const wallet = Wallet.createRandom();
      const keyPairFromPublic = new KeyPair(wallet.publicKey);
      // @ts-expect-error
      expect(() => keyPairFromPublic.mulPublicKey(1)).to.throw('Input must be instance of RandomNumber or string');
      expect(() => keyPairFromPublic.mulPublicKey('1234')).to.throw('Strings must be in hex form with 0x prefix');
    });

    //验证乘以的数类似防坑
    it('throws when mulPrivateKey is provided a bad input', async () => {
      const keyPairFromPrivate = new KeyPair(wallet.privateKey);
      const keyPairFromPublic = new KeyPair(wallet.publicKey);
      // @ts-expect-error
      expect(() => keyPairFromPrivate.mulPrivateKey(1)).to.throw('Input must be instance of RandomNumber or string');
      expect(() => keyPairFromPrivate.mulPrivateKey('1234')).to.throw('Strings must be in hex form with 0x prefix');
      expect(() => keyPairFromPublic.mulPrivateKey('0x1')).to.throw('KeyPair has no associated private key');
    });

    //验证无法交易txhash
    it('throws when instanceFromTransaction is provided an invalid transaction hash', async () => {
      const errorMsg = 'Invalid transaction hash provided';
      // @ts-expect-error
      expectRejection(KeyPair.instanceFromTransaction(1, ethersProvider), errorMsg);
      expectRejection(KeyPair.instanceFromTransaction('0x1', ethersProvider), errorMsg);
    });

    //验证错误公钥压缩
    it('throws when compressPublicKey is provided bad inputs', async () => {
      const errorMsg = 'Must provide uncompressed public key as hex string';
      // @ts-expect-error
      expect(() => KeyPair.compressPublicKey(1)).to.throw(errorMsg);
      expect(() => KeyPair.compressPublicKey('1')).to.throw(errorMsg);
      expect(() => KeyPair.compressPublicKey('0x1')).to.throw(errorMsg);
    });

    //验证非曲线算法公钥
    it('throws when compressPublicKey is provided a public key not on the curve', () => {
      expect(() => KeyPair.compressPublicKey(badPublicKey)).to.throw('Point is not on elliptic curve');
      expect(() => KeyPair.compressPublicKey(badPublicKey.slice(2))).to.throw('Point is not on elliptic curve'); //去掉前2位
    });
    //验证解压缩
    it('throws when getUncompressedFromX is provided bad inputs', async () => {
      // @ts-expect-error
      expect(() => KeyPair.getUncompressedFromX(1)).to.throw('Compressed public key must be a BigNumber or string');
    });
  });
});
